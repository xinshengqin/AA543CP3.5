\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb}

\usepackage{hyperref}  % for urls and hyperlinks
%\usepackage[pdftex]{graphicx} 
\usepackage{caption}
\usepackage{subcaption}
%\usepackage{enumitem}


\setlength{\textwidth}{6.2in}
\setlength{\oddsidemargin}{0.3in}
\setlength{\evensidemargin}{0in}
\setlength{\textheight}{8.7in}
\setlength{\voffset}{-.7in}
\setlength{\headsep}{26pt}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt}


\title{Documentation to the code for computer project 3 in AA543 and some thoughts}

\author{Xinsheng Qin xsqin@uw.edu}

\begin{document}

\maketitle

\begin{abstract}
In this documentation, a detailed description to the code for computer project 3 in class AA543 is given.
This code includes modules for mesh generation, applying boundary condition and initial condition, and solver for solving some partial difference equations (PDE). 
At the end are some of my thoughts about this project.
\end{abstract}

\section{General Structure of the code}
This code is designed to solve for fluid fields, if given a domain (currently only 1D is available), initial condition on the domain, boundary condition on the boundary and the governing equations to be solved.
\par

A \textbf{\textit{mesh}} object should be first defined and initialized to specify the domain. 
Then initial condition is used to create a \textbf{\textit{velocityField}} object to specify a velocity field with initial value known. 
Finally, the \textbf{\textit{velocityField}} object is passed to one of the solver function defined in \textbf{\textit{solver\_1d.py}} to solve for fluid field until a final time. 

\section{Introduction to all modules in the code}
    \subsection{\textbf{\textit{mesh.py}}}
    This file contains definition of \textbf{\textit{mesh}} class.
        \subsubsection{Attributes}
        \begin{description}
            \item[$\bullet$] \textbf{startPoint} : \textbf{float}
                \par
		Coordinate of left-most grid point (j=1), excluding ghost points.
            \item[$\bullet$] \textbf{endPoint} : \textbf{float}
                \par
		Coordinate of right-most grid point (j=J), excluding ghost points.
            \item[$\bullet$] \textbf{name} : \textbf{str}
                \par
		Name for this mesh object.
            \item[$\bullet$] \textbf{numberOfPoints} : \textbf{int}
                \par
		Total number of grid points for this mesh, excluding ghost points. 
            \item[$\bullet$] \textbf{ratio} : \textbf{float}
                \par
		The ratio of maximum grid spacing to minimum grid spacing.
            \item[$\bullet$] \textbf{Nonuniform} : \textbf{bool}
                \par
		A bool type variable specifying if this mesh is nonuniform or not.
            \item[$\bullet$] \textbf{coordinates} : \textbf{list}
                \par
		A list containing coordinates for all grid points, including ghost points.
            \item[$\bullet$] \textbf{gapSpaceDistribution} : \textbf{list}
                \par
		A list containing space between each two grid points, including ghost points.
            \item[$\bullet$] \textbf{minimumDeltaX} : \textbf{float}
                \par
		Minimum grid space in this mesh.
            \item[$\bullet$] \textbf{xclusteredPoint} : \textbf{float}
                \par
		For nonuniform mesh only. It specify coordinate of a point where the nonuniform mesh is clustered at.
	\end{description}
	\subsubsection{Methods}
        \begin{description}
	    \item[$\bullet$] \textbf{createUniformMesh}()
                \par
		This function builds uniform mesh and returns grip point coordinates and grid space.
	    \item[$\bullet$] \textbf{createNonuniformMesh}()
		\par
		This function builds nonuniform mesh with algorithm introduced in \ref{sec:algorithm} and returns grip point coordinates and grid space.
	    \item[$\bullet$] \textbf{plot\_pointVsIndex}()
		\par
                Call matplotlib to plot the mesh. Save a png file plotting coordinates of each grid point versus its index in the list (index starts from 0) in current folder.
	    \item[$\bullet$] \textbf{plot\_gapSpaceVsIndex}()
		\par
                Call matplotlib to plot the mesh. Save a png file plotting distance between each two points versus index of first point in each pair in the list (index starts from 0) in current folder.
	    \item[$\bullet$] \textbf{plot\_gapSpaceVsX}()
		\par
                Call matplotlib to plot the mesh. Save a png file plotting distance between each two points versus coordinate of first point in each pair in the list.
	\end{description}
	\subsubsection{Algorithm}\label{sec:algorithm}
	    To generate a uniform grid is quite easy thus we mainly focus on how to generate a nonuniform below.\par
	    Let's first divide the whole domain into two parts from the cluster point and mark the cluster point as $i=1$. According to the length fraction of left part and right part, we assign corresponding number of grid points in these two areas. 
	    \begin{equation}
		n_1 = \frac{x_c-x_1}{x_n-x_1}
	    \end{equation}
	    \begin{equation}
		n_2 = n - n_1
	    \end{equation}
	    \begin{equation}
		n_{max} = max\{n_1,n_2\}
	    \end{equation}
	    where, \par
	    $n_1$ represent number of points to the left of cluster point.\par
	    $n_2$ represent number of points to the right of cluster point. \par 
	    $x_1$ is the coordinate of starting point of the domain. \par
	    $x_2$ is the end point of the domain. \par
	    Now let's assume right part is longer than left part.(If left part is longer, the code can tell and manipulate it in a similar way.) We mark the points in right part using index from $i=1,2\dots$ to $i=n_2$, where $i=1$ is the cluster point. \par
	For each point in this region, we assume its coordinate can be computed using:\begin{equation}x_i=f(i)=i^2+bi \end{equation}\par
	    Since we are given the degree of clustering, $\eta$, the coordinates must satisfy:
	    \begin{equation}
		\eta=\frac{f(n_2)-f(n_2-1)}{f(2)-f(1)}=\frac{2n_2-1+b}{2\times2-1+b}
	    \end{equation}
	    From this equation we can solve for parameter $b$:
	    \begin{equation}
		b=\frac{2n_2-1-3\eta}{\eta-1}
	    \end{equation}
	    Then we start to compute the coordinates of every point in right part using:
	    \begin{equation}
		\overline{f(i)^+}=x_c+[f(i)-f(1)], i=1,2,3,\dots n_2
	    \end{equation}
	    If we make the left part and right part symmetric with respect to cluster point, and mark the points in left part from right to left as $2,3,\dots,n_1+1$, we can use a similar function to compute the coordinate of the points in left part:
	    \begin{equation}
		\overline{f(i)^-}=x_c-[f(i)-f(1)], i=2,3,\dots n_1
	    \end{equation}
	    As a summary, the indices of all points from left to right are $n_1,n_1-1,\dots,3,2,1,2,3,\dots,n_2-1,n_2$. After computing all their coordinates using equation (7) or (8) and puting them in a list, we have a original grid. But we still need to scale and shift it into a specific range specified by input as start point and end point.\par
	    Let's mark all points in the list with new indices: $1,2,3,\dots,n-1,n$.\par
	    New coordinate of each point can be computed using:
	    \begin{equation}
		f(i)_{new}=x_{startpoint}+\frac{x_i-x_{startpoint}}{x_{endpoint}-x_{startpoint}},i=1,2,3,\dots,n-1,n
	    \end{equation}
	    Now we have a grid that fulfill the requirement. The $i$th element in the list is the coordinate of $i$th grid point.

    \subsection{\textbf{\textit{velocityField.py}}}
    This file contains definition of \textbf{\textit{velocityField}} class and several functions for setting initial condition for the class.
        \subsubsection{Attributes}
        \begin{description}
            \item[$\bullet$] \textbf{mesh} : \textbf{mesh}
                \par
                A mesh object on which the velocity field is described.
            \item[$\bullet$] \textbf{u\_xmin} : \textbf{float}
                \par
                Velocity for left-most two ghost points at j=-1,0. For case where dirichlet boundary condition is chosen.
            \item[$\bullet$] \textbf{u\_xmax} : \textbf{float}
                \par
                Velocity for right-most two ghost points at j=J+1,J+2. For case where dirichlet boundary condition is chosen.
            \item[$\bullet$] \textbf{name} : \textbf{str}
                \par
                Name for this velocityField object.
            \item[$\bullet$] \textbf{BC} : \textbf{str}
                \par
                Boundary condition for this velocity field.
            \item[$\bullet$] \textbf{u0} : \textbf{list}
                \par
                A list contains velocity values at each grid point.
            \item[$\bullet$] \textbf{u} : \textbf{numpy.array}
                \par
                A numpy array contains velocity values at each grid point and at each time step.
                The \textit{n-th} row contains velocity values at each grid point at time step $n-1$
                
        \end{description}

        \subsubsection{Methods}
%        \begin{description}[style=unboxed]
        \begin{description}
            \item[$\bullet$]\textbf{\_\_init\_\_}(mesh, IC, IC\_para1, IC\_para2, BC='periodic",
                \par
                u\_xmin=None, u\_xmax=None, name='default\_velocityField')
                \par
                Constructor for the class. 
            \item[$\bullet$] \textbf{applyBC}(i)
                \par
                This function assigns velocity values to 4 ghost points at time step $i$ according to value of the attribute \textbf{BC}. 
                Three types of boundary conditions are available currently: periodic B.C., dirichlet B.C., neumann B.C.
            \item[$\bullet$] \textbf{plot\_pointVsIndex}()
                \par
                Call matplotlib to plot the mesh. Save a png file plotting coordinates of each grid point versus its index in the list (index starts from 0) in current folder.
            \item[$\bullet$] \textbf{plot\_gapSpaceIndex}()
                \par
                Call matplotlib to plot the mesh. Save a png file plotting distance between each two points versus index of first point in each pair in the list (index starts from 0) in current folder.
            \item[$\bullet$] \textbf{plot\_uVsIndex}()
                \par
                Call matplotlib to plot the velocity field. Save a png file plotting velocity at each grid point versus index of the grid point in the list (index starts from 0) in current folder.
            \item[$\bullet$] \textbf{plot\_uVsX}(i,filename)
                \par
                Call matplotlib to plot the velocity field. 
                Save a png file with \textit{filename} as prefix of file name, plotting velocity at time step $i$ at each grid point versus coordinates of the grid point. 

        \end{description}
        \subsubsection{Other Functions}
        \begin{description}
            \item[$\bullet$]\textbf{IC\_gaussian}(xmin, xmax, xpeak, width, x)
                \par
                A function to be passed to the \textbf{\textit{velocityField}} class. 
                It will return velocity value at a grid point with coordinate $x$.
                \par
                \textit{xmin} is coordinate of the 1st grid point (j=1).
                \textit{xmax} is coordinate of the last grid point (j=J).
                \textit{xpeak} is coordinates of a grid point where peak of the gaussian wave should be located at.
                \textit{width} control width of the gaussian wave.
                \par
                The equation used to describe the gaussian wave is 
                $$ u(x) = 1 + exp({\frac{-10}{width}(\frac{(x-xpeak)*(xmax+xmin)}{xmax-xmin})^2}) $$

            \item[$\bullet$]\textbf{IC\_stepFunction}(xmin xmax, xpeak, width, x)
                \par
		This function is used to produce a step function centered at x=0.
		\textit{width} is the length of range in which the function has non-zero value.
		\textit{xpeak} is peak value of the step function. (all points in $-width/2<x<width/2$ should be initialized with this value)
                Note: \textit{xmin} and \textit{xmax} are not used.
            \item[$\bullet$]\textbf{IC\_sin}(xmin xmax, amplitude, circle\_frequency, x)
                \par
                A function to be passed to the \textbf{\textit{velocityField}} class. 
                It will return velocity value at a grid point with coordinate $x$.
                The equation used to describe velocity distribution is
                $$ u(x) = amplitude*sin(circle_frequency*x) $$
		\par
                Note: \textit{xmin} and \textit{xmax} are not used.

        \end{description}

    \subsection{\textbf{\textit{solver\_1d.py}}}
        This module defines several functions to numerically solve for solution of some PDEs.
        \par
        \subsubsection{Solver Functions}
        \begin{description}
	    \item[$\bullet$]\textbf{LaxWendroff}(a, velocityField, tfinal, nsteps, output\_path='./plots')
                \par
		This solver uses Lax-Wendroff method to solve time-dependent linear advection equation on a uniform grid explicitly.
		It proceeds with the equation
		$$
		Q^{n+1}_i = Q^n_i - \frac{u\triangle t}{2\triangle x}(Q^n_{i+1} - Q^n_{i-1}) + (\frac{u\triangle t}{\triangle x})^2(\frac{Q^n_{i+1}-2Q^n_i+Q^n_{i-1}}{2})
		$$
		\textit{a} is propagating speed of the wave.
		\textit{velocityField} is a \textbf{\textit{velocityField}} object.
		\textit{tfinal} is final time of the simulation.
		\textit{nsteps} is number of time steps.
		\textit{output\_path} is a relative path to current folder where output of simulation should be written. 
	    \item[$\bullet$]\textbf{nonlinear\_solver}(velocityField, tfinal, cfl, flux\_function, mu=0.001, output\_path='./plots')
                \par
		The equation to be solved is burger's equation
		$$
		u_t + (\frac{1}{2}u^2)_x = \mu u_{xx}
		$$
		where,$u$ is velocity, $\mu$ artificial viscosity.
		Discretizing it gives us
		$$
		\frac{u^{n+1}_j-u^n_j}{\triangle t} + \frac{f^+_j-f^+_{j-1}}{x_j-x_{j-1}} + \frac{f^-_{j+1}-f^-_j}{x_{j+1}-x_{j}} = \mu {\nabla}_x (\frac{u_{j+1}-u_{j}}{x_{j+1}-x_j)}
		$$
		$$
		    \frac{u^{n+1}_j-u^n_j}{\triangle t} + \frac{f^+_j-f^+_{j-1}}{x_j-x_{j-1}} + \frac{f^-_{j+1}-f^-_j}{x_{j+1}-x_{j}} = \frac{\mu}{x_{j+1}-x_j}(\frac{u_{j+1}-u_j}{x_{j+1}-x_j}-\frac{u_j-u_{j-1}}{xj-x_{j-1}}) 
		$$
		where $f^+ = max\{f,0\}$ and $f^- = min\{f,0\}$
		\par
		Rearranging the equation gives us
		$$
		u^{n+1}_j = u^n_j + \triangle t \Bigg[\frac{\mu}{x_{j+1}-x_j} \bigg(\frac{u_{j+1}-u_j}{x_{j+1}-x_j}-\frac{u_j-u_{j-1}}{x_j-x_{j-1}}\bigg)-\frac{f^+_j-f^+_{j-1}}{x_j-x_{j-1}} - \frac{f^-_{j+1}-f^-{j}}{x_{j+1}-x_j} \Bigg]
		$$
	\end{description}

\section{A Simple Sample to Demonstrate How to Implement the Code} 
\section{My Thoughts on This Project}

The code will be updated and new features will be added in. 
All latest code is public at GitHub: https://github.com/xinshengqin/AA543CP3.5.git. 

\end{document}
